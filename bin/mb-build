#!/usr/bin/perl -w
#
#

use strict;
use warnings;
use English qw( -no_match_vars );
use File::Spec::Functions qw( catdir splitdir );
use File::Path;
use FindBin;
use File::Find::Rule;
use IO::File;
use Data::Dumper;

# We assume everything is based on the home of the User

my $base     = (getpwuid($EUID))[7];
my $prefix   = make_sure_directory_exists($base, 'baseline');
my $src_base = parent_dir($FindBin::Bin);
my $rule_dir = catdir($src_base, 'rules');

my $rules = load_rules($rule_dir);

build_all_rules($rules);



#########
# Builder

sub build_all_rules {
  my ($todo) = @_;
  my %done;
  
  while (%$todo) {
    my $next = _seach_for_available_rule($todo, \%done);
    my $name = $next->{name};
    
    my $ok = build_rule($next);
    last unless $ok;
    
    $done{$name} = delete $todo->{$name};
  }
  
  return \%done;
}

sub build_rule {
  my ($rule) = @_;

  # ... generate shell script...
  my $script = gen_compile_script($rule);
  # ... run shell script, capture output ...
  # ... check output for errors ...
  
  1;
}

sub _seach_for_available_rule {
  my ($todo, $done) = @_;
  
  # Reset each iterator
  keys %$todo;
  
  RULE:
  while (my ($name, $rule) = each %$todo) {
    my $reqs = $rule->{requires};
    foreach my $req (@$reqs) {
      next RULE unless exists $done->{$req};
    }
    return $rule;
  }

  fatal("Could not decide on next rule to run: ", $todo, $done);  
}


########################
# Shell script generator

sub gen_compile_script {
  my ($rule) = @_;
  my $script;
  
  $script = _strip_common_prefix(<<"  END_OF_HEADER");
      #!/bin/sh
      #
      # Generated by mb-build, DO NOT EDIT
      # 
      # Compile script for '$rule->{name}'
      # based on rules from:
      #   $rule->{file}
      #
      
      BASELINE='$rule->{vars}{BASELINE}';
      if [ ! -d "\$BASELINE" ] ; then
        mkdir -p "\$BASELINE"
      fi
      cd "\$BASELINE"
      
      for dir in build src ; do
        if [ ! -d \$dir ] ; then
          mkdir \$dir
        fi
      done
      
  END_OF_HEADER

  $script .= gen_script_fetch($rule);  
  $script .= gen_script_actions($rule);

  return $script;
}

sub gen_script_fetch {
  my ($rule) = @_;
  
  return "# fetch step not generated, lacking source\n"
    unless exists $rule->{source};
  
  return _strip_common_prefix(<<"  END_OF_FETCH");
      # Fetch source
      if [ ! -e "src/$rule->{vars}{TARBALL}" ] ; then
        (
          cd src
          curl -L -O "$rule->{source}{url}"
        )
      fi
      
  END_OF_FETCH
}

sub gen_script_actions {
  my ($rule) = @_;
  my $script = '';
  
  my $actions = $rule->{actions};
  
  foreach my $action (@$actions) {
    my $action_name = $action->{action};

    my $g;
    $g = \&_gen_action_autoconf       if $action_name eq 'autoconf';
    $g = \&_gen_action_prepare_source if $action_name eq 'prepare_source';
    $g = \&_gen_action_configure      if $action_name eq 'configure';
    $g = \&_gen_action_make           if $action_name eq 'make';
    $g = \&_gen_action_shell          if $action_name eq 'shell';
    fatal("Action '$action_name' not supported") unless $g;
        
    $script .= $g->($rule, $action);
  }
  
  return $script;
}

sub _gen_action_autoconf {
  my ($rule, $action) = @_;
  
  return _gen_action_prepare_source(@_)
       . _strip_common_prefix(<<"  END_OF_AUTOCONF_BLOCK");
      # Autoconf package
      (
        cd build/$rule->{vars}{PACKAGE}
        ./configure "--prefix=$rule->{vars}{BASELINE}"
        make
        make install
      )
      
  END_OF_AUTOCONF_BLOCK
}

sub _gen_action_prepare_source {
  my ($rule, $action) = @_;
  
  return _strip_common_prefix(<<"  END_OF_PREPARE_SOURCE_BLOCK");
      # Prepare source
      if [ ! -d "build/$rule->{vars}{PACKAGE}" ] ; then
        (
          cd build
          tar zxf "../src/$rule->{vars}{TARBALL}"
        )
      fi
      
      (
        cd build/$rule->{vars}{PACKAGE}
        if [ -e Makefile ] ; then
          make distclean
        fi
      )
      
  END_OF_PREPARE_SOURCE_BLOCK
}

sub _gen_action_configure {
  my ($rule, $action) = @_;
  
  return _strip_common_prefix(<<"  END_OF_CONFIGURE_BLOCK");
      # Configure
      (
        cd build/$rule->{vars}{PACKAGE}
        $action->{args}
      )
      
  END_OF_CONFIGURE_BLOCK
}

sub _gen_action_make {
  my ($rule, $action) = @_;
  
  my $args = $action->{args};
  $args = '' unless defined $args;
  
  return _strip_common_prefix(<<"  END_OF_MAKE_BLOCK");
      # Make something
      (
        cd build/$rule->{vars}{PACKAGE}
        make $args
      )
      
  END_OF_MAKE_BLOCK
}

sub _gen_action_shell {
  my ($rule, $action) = @_;
  
  my $script = _strip_common_prefix(<<"  END_OF_SHELL_HEADER_BLOCK");
      # Shell
      (
        cd build/$rule->{vars}{PACKAGE}
  END_OF_SHELL_HEADER_BLOCK
  
  foreach my $cmd (@{$action->{script}}) {
    $script .= "  $cmd\n";
  }
  
  $script .= _strip_common_prefix(<<"  END_OF_SHELL_FOOTER_BLOCK");
      )
  END_OF_SHELL_FOOTER_BLOCK

  return $script;
}


##############
# Rules parser

sub load_rules {
  my ($rule_dir) = @_;
  my %rules;
  
  my @rule_files = File::Find::Rule->file->name('*.rule')->in($rule_dir);
  
  foreach my $rule_file (@rule_files) {
    my $rule = parse_rule_file($rule_file);

    my $name = $rule->{name};
    fatal("Missing name tag in rule '$rule_file'") unless $name;

    $rules{$name} = $rule; 
  }
  
  return \%rules;
}

sub parse_rule_file {
  my ($rule_file) = @_;
  my %rule = (
    file => $rule_file,
    vars => {
      BASELINE => $prefix,
    },
  );

  my $rule_fh = IO::File->new($rule_file, 'r')
    || fatal("Could not open rule file '$rule_file': $!");
  
  my $parser = \&_parse_rule_globals;

  while (defined(my $rule_line = $rule_fh->getline)) {
    do {
      my ($new_line, $next_parser) = $parser->(\%rule, $rule_line);
      $parser = $next_parser if $next_parser;
      $rule_line = $new_line;
    } while ($rule_line);
  }
  
  return \%rule;
}

sub _parse_rule_comments {
  my ($rule, $rule_line) = @_;
  
  return if $rule_line =~ m/^\s*(#.*)?$/;

  return ($rule_line);  
}

sub _parse_rule_strip_comments {
  my ($rule, $rule_line) = @_;

  $rule_line =~ s/^\s*(.+?)\s*$/$1/;
  $rule_line =~ s/#.*$//;  

  return ($rule_line);  
}

sub _parse_rule_globals {
  my ($rule) = @_;
  
  return unless _parse_rule_comments(@_);
  my ($rule_line) = _parse_rule_strip_comments(@_);

  my $actions  = $rule->{actions}  ||= [];
  my $requires = $rule->{requires} ||= [];
  my $lib_dirs = $rule->{lib_dirs} ||= [];

  if ($rule_line =~ m/^set\s+(\S+)\s+(.+)$/) {
    $rule->{vars}{$1} = _expand_vars($rule, $2);
  }
  elsif ($rule_line =~ m/^source\s+(.+)/) {
    $rule->{source}{url} = _expand_vars($rule, $1);
  }
  elsif ($rule_line =~ m/^name\s+(.+)/) {
    $rule->{name} = _expand_vars($rule, $1);
  }
  elsif ($rule_line =~ m/^requires\s+(.+)/) {
    push @$requires, _expand_vars($rule, $1);
  }
  elsif ($rule_line =~ m/^library_path\s+(.+)/) {
    push @$lib_dirs, _expand_vars($rule, $1);
  }
  elsif ($rule_line =~ m/^source\s+(.+)/) {
    $rule->{source}{url} = _expand_vars($rule, $1);
  }
  elsif ($rule_line =~ m/^(autoconf|prepare_source|configure|make)(?:\s+(.+))?$/) {
    push @$actions, {
      action => $1,
      args   => $2,
    };
  }
  elsif ($rule_line =~ m/^shell$/) {
    push @$actions, {
      action => 'shell',
      script => [],
    };
    
    return (undef, \&_parse_rule_shell);
  }
  else {
    fatal("Unparsable rule line in '$rule->{file}': '$rule_line'")
  }
  
  return;
}

sub _parse_rule_shell {
  my ($rule, $rule_line) = @_;
  
  return (undef, \&_parse_rule_globals) if $rule_line =~ m/^---$/;
  
  my $shell  = $rule->{actions}[-1];
  my $script = $shell->{script};
  
  # Remove leading WS prefix
  ($shell->{prefix}) = $rule_line =~ m/^(\s+)\S/
    unless defined $shell->{prefix};
  $rule_line =~ s/^$shell->{prefix}// if defined $shell->{prefix};
  
  chomp($rule_line);
  push @$script, _expand_vars($rule, $rule_line);
  
  return;
}

sub _expand_vars {
  my ($rule, $text) = @_;
  
  my $v = $rule->{vars} ||= {};
  $text =~
    s/
      \$                  # A $ symbol
      (                   # followed by label
        [A-Z]             # with a mandatory LETTER
        [A-Z0-9_]*        # followed by optional LETTER or DIGITS or _
      )
    /
      exists $v->{$1}?      # If such var exists
        $v->{$1}            # use it
        :                   # if not complain loudly
        fatal("Var '$1' is not defined in rule file $rule->{file}")  
    /gex;
  
  return $text;
}


##################
# Filesystem utils

sub make_sure_directory_exists {
  my $dir = catdir(@_);
  if (! -e $dir) {
    mkpath($dir, 0, 0755);
    return $dir;
  }
  
  return $dir if -d _;
  
  fatal("Path '$dir' exists but it is not a directory");
}

sub parent_dir {
  my @dirs = splitdir($_[0]);
  pop @dirs;
  return catdir(@dirs);
}


##############
# String utils

sub _strip_common_prefix {
  my ($text) = @_;
  
  my ($prefix) = $text =~ m/^(\s+)/;
  $text =~ s/^$prefix//gm;
  
  return $text;
}


###########
# Log stuff

sub fatal {
  print STDERR "FATAL: ";
  foreach my $t (@_) {
    if (ref($t)) {
      print STDERR "\n", Dumper($t);
    }
    else {
      print STDERR $t;
    }
  }
  print STDERR "\n";
  exit(1);
}

